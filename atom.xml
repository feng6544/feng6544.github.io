<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.fengxie6544.top</id>
    <title>风斜的博客</title>
    <updated>2022-05-30T14:06:06.099Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.fengxie6544.top"/>
    <link rel="self" href="https://blog.fengxie6544.top/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://blog.fengxie6544.top/images/avatar.png</logo>
    <icon>https://blog.fengxie6544.top/favicon.ico</icon>
    <rights>All rights reserved 2022, 风斜的博客</rights>
    <entry>
        <title type="html"><![CDATA[tomcat 500错误]]></title>
        <id>https://blog.fengxie6544.top/post/tomcat-500-cuo-wu/</id>
        <link href="https://blog.fengxie6544.top/post/tomcat-500-cuo-wu/">
        </link>
        <updated>2022-04-03T10:12:27.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://blog.fengxie6544.top/post-images/1648980776906.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MVC]]></title>
        <id>https://blog.fengxie6544.top/post/mvc/</id>
        <link href="https://blog.fengxie6544.top/post/mvc/">
        </link>
        <updated>2022-04-02T14:56:33.000Z</updated>
        <content type="html"><![CDATA[<h3 id="springmvc的特点">SpringMVC的特点</h3>
<ol>
<li>轻量级，简单</li>
<li>高效，基于响应的MVC框架</li>
<li>与Spring兼容好，无缝结合</li>
<li>约定优于配置</li>
<li>功能强大</li>
<li>简洁灵活</li>
</ol>
<h3 id="spring-mvc所有的请求都经过dispatcherservlet来统一分发">Spring MVC所有的请求都经过DispatcherServlet来统一分发</h3>
<h3 id="mvc的controller注解">MVC的Controller（注解）</h3>
<h4 id="优点">优点：</h4>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解决Address localhost:1099 is already in use]]></title>
        <id>https://blog.fengxie6544.top/post/jie-jue-address-localhost1099-is-already-in-use/</id>
        <link href="https://blog.fengxie6544.top/post/jie-jue-address-localhost1099-is-already-in-use/">
        </link>
        <updated>2022-04-02T06:22:51.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>打开CMD命令行，运行   netstat -ano | find &quot;1099&quot;  通过端口号找到pid</li>
<li>tasklist | find &quot;****&quot; 通过pid找到进程（“****”是pid）</li>
<li>关闭进程   taskkill /f /t /im java.exe</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://blog.fengxie6544.top/post-images/1648880889851.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Intellij IDEA 添加jar包]]></title>
        <id>https://blog.fengxie6544.top/post/intellij-idea-tian-jia-jar-bao/</id>
        <link href="https://blog.fengxie6544.top/post/intellij-idea-tian-jia-jar-bao/">
        </link>
        <updated>2022-04-02T04:52:55.000Z</updated>
        <content type="html"><![CDATA[<h3 id="通过modules的dependencies添加">通过Modules的Dependencies添加</h3>
<ol>
<li>文件-&gt;项目结构<br>
<img src="https://blog.fengxie6544.top/post-images/1648875371635.png" alt="" loading="lazy"></li>
<li>选择本地jar包<br>
<img src="https://blog.fengxie6544.top/post-images/1648875759401.png" alt="" loading="lazy"></li>
<li>应用</li>
</ol>
<h3 id="通过libraries添加">通过Libraries添加</h3>
<ol>
<li>文件-&gt;项目结构<br>
<img src="https://blog.fengxie6544.top/post-images/1648875371635.png" alt="" loading="lazy"></li>
<li>删除原有jar包<br>
<img src="https://blog.fengxie6544.top/post-images/1648876357279.png" alt="" loading="lazy"></li>
<li>添加新的Libraries<br>
<img src="https://blog.fengxie6544.top/post-images/1648876397050.png" alt="" loading="lazy"></li>
<li>将新的Libraries放进原项目中</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring小记]]></title>
        <id>https://blog.fengxie6544.top/post/java/</id>
        <link href="https://blog.fengxie6544.top/post/java/">
        </link>
        <updated>2022-03-31T08:10:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="spring">spring</h1>
<h4 id="优点">优点</h4>
<ol>
<li>spring是一个免费的开源的框架（容器）</li>
<li>spring是一个轻量级的、非入侵式的框架</li>
<li>控制反转（IOC）、面向切面编程（AOP）</li>
<li>支持事务的整理，对框架整合的支持</li>
</ol>
<p>spring是一个轻量级的控制反转、面向切面编程的框架</p>
<h4 id="组成">组成</h4>
<figure data-type="image" tabindex="1"><img src="https://blog.fengxie6544.top/post-images/1648715807083.png" alt="" loading="lazy"></figure>
<h4 id="ioc理论推导">IOC理论推导</h4>
<pre><code class="language-java">&lt;dependency&gt;
   &lt;groupId&gt;org.springframework&lt;/groupId&gt;
   &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
   &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
    
&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
                &lt;source&gt;12&lt;/source&gt;
                &lt;target&gt;12&lt;/target&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
</code></pre>
<pre><code class="language-java">//ioc的原型
//利用set动态控制值的注入   实现控制反转
private UserDao userDao;
public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
</code></pre>
<p>降低系统的耦合性</p>
<p><strong>控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法</strong>。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，所谓控制反转就是：获得依赖对象的方式反转了。</p>
<figure data-type="image" tabindex="2"><img src="https://blog.fengxie6544.top/post-images/1648817472143.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">类型 变量名 = new 类型()
id = 变量名
class = new 的对象
property 相当于给对象中的属性设置一个值
</code></pre>
<p>所谓ioc，就是对象由spring来创建，管理，装配</p>
<h4 id="xml配置">xml配置</h4>
<pre><code class="language-java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;


&lt;/beans&gt;


ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);
</code></pre>
<p>带参构造</p>
<pre><code class="language-xm">//下表赋值
&lt;bean id=&quot;user&quot; class=&quot;com.feng.pojo.User&quot;&gt;
        &lt;constructor-arg index=&quot;0&quot; value=&quot;fengxie&quot;/&gt;
    &lt;/bean&gt;
//直接使用变量名
&lt;bean id=&quot;user&quot; class=&quot;com.feng.pojo.User&quot;&gt;
        &lt;constructor-arg name=&quot;name&quot; value=&quot;22222&quot;/&gt;
    &lt;/bean&gt;
</code></pre>
<p>导入其他配置文件</p>
<pre><code class="language-xm">&lt;import resource=&quot;beans.xml&quot;/&gt;
</code></pre>
<p>SET方式注入：</p>
<p>​	依赖注入：set方式注入</p>
<pre><code>1. 依赖：bean对象的创建依赖容器
1. 注入：bean对象的属性，由容器注入
</code></pre>
<p>bean的作用域</p>
<ol>
<li>单例模式</li>
<li>原型模式：每次从容器中get的是一个新对象</li>
<li>其余 request session application只能在web开发中使用</li>
</ol>
<h4 id="自动装配">自动装配</h4>
<pre><code class="language-xml">&lt;!--
    byname:自动在容器上下文寻找 set 方法对应id的值
	bytype :属性相同
    --&gt;
    &lt;bean id=&quot;people&quot; class=&quot;com.feng.pojo.People&quot; autowire=&quot;byName&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;feng&quot;/&gt;
    &lt;/bean&gt;


</code></pre>
<p>注解实现自动注入(需满足以下支持)（可以忽略set方法）</p>
<h4 id="context约束">context约束</h4>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:annotation-config/&gt;

&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">@Autowired(required = false)    //对象可以为NULL
@Qualifier(value=&quot;&quot;)

@Resource(name=&quot;&quot;)

//autowired resource都是自动装配
//autowired通过bytype 然后byname  resource先用byname 失败则使用bytype
</code></pre>
<h4 id="注解">注解：</h4>
<p>@Component</p>
<ol>
<li>dao【@Repository】</li>
<li>service【@Service】</li>
<li>controller【@Controller】</li>
</ol>
<h4 id="静态代理">静态代理：</h4>
<ol>
<li>
<p>接口</p>
<pre><code class="language-java">public interface Rent {
    public void rent();
}
</code></pre>
</li>
<li>
<p>真实角色</p>
<pre><code class="language-java">public class Host implements Rent{

    @Override
    public void rent() {
        System.out.println(&quot;房东出租房子&quot;);
    }
}
</code></pre>
</li>
<li>
<p>代理角色</p>
<pre><code class="language-java">public class Proxy implements  Rent{

    public Host host;

    public Proxy() {
    }

    public Proxy(Host host) {
        this.host = host;
    }



    @Override
    public void rent() {
        seeHouse();
        host.rent();
        hetong();
        fare();
    }

    public void seeHouse(){
        System.out.println(&quot;中介 带你看房&quot;);
    }

    public void hetong(){
        System.out.println(&quot;签合同&quot;);
    }

    public void fare(){
        System.out.println(&quot;收中介费&quot;);
    }
}
</code></pre>
</li>
<li>
<p>客户访问代理</p>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        Host host = new Host();

        Proxy proxy = new Proxy(host);

        proxy.rent();
    }
}
</code></pre>
</li>
</ol>
<h4 id="浅谈aop">浅谈AOP</h4>
<figure data-type="image" tabindex="3"><img src="https://blog.fengxie6544.top/post-images/1648715767237.png" alt="" loading="lazy"></figure>
<h4 id="动态代理">动态代理</h4>
<pre><code class="language-java">import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
//使用这个类 自动生产代理类
public class ProxyInvocationHandler implements InvocationHandler {

    //被代理的接口
    private Object target;

    public void setTarget(Object target) {
        this.target = target;
    }

    //生成得到代理类
    public Object getProxy(){
        return Proxy.newProxyInstance(this.getClass().getClassLoader(),target.getClass().getInterfaces(),this);
    }

    //处理代理示例，返回结果
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //动态代理的本质就是使用反射去实现
        Object result = method.invoke(target, args);
        return result;
    }
}

</code></pre>
<h4 id="aop实现">AOP实现</h4>
<p>所需支持：</p>
<pre><code class="language-xml">    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.9.4&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<h4 id="aop组成">AOP组成</h4>
<figure data-type="image" tabindex="4"><img src="https://blog.fengxie6544.top/post-images/1648715595163.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
</feed>