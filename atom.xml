<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://localhost:4000</id>
    <title>风斜的博客</title>
    <updated>2022-03-31T08:45:08.824Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://localhost:4000"/>
    <link rel="self" href="http://localhost:4000/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>http://localhost:4000/images/avatar.png</logo>
    <icon>http://localhost:4000/favicon.ico</icon>
    <rights>All rights reserved 2022, 风斜的博客</rights>
    <entry>
        <title type="html"><![CDATA[Spring小记]]></title>
        <id>http://localhost:4000/post/java/</id>
        <link href="http://localhost:4000/post/java/">
        </link>
        <updated>2022-03-31T08:10:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="spring">spring</h1>
<h4 id="优点">优点</h4>
<ol>
<li>spring是一个免费的开源的框架（容器）</li>
<li>spring是一个轻量级的、非入侵式的框架</li>
<li>控制反转（IOC）、面向切面编程（AOP）</li>
<li>支持事务的整理，对框架整合的支持</li>
</ol>
<p>spring是一个轻量级的控制反转、面向切面编程的框架</p>
<h4 id="组成">组成</h4>
<figure data-type="image" tabindex="1"><img src="http://localhost:4000/post-images/1648715807083.png" alt="" loading="lazy"></figure>
<h4 id="ioc理论推导">IOC理论推导</h4>
<pre><code class="language-java">&lt;dependency&gt;
   &lt;groupId&gt;org.springframework&lt;/groupId&gt;
   &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
   &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
    
&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
                &lt;source&gt;12&lt;/source&gt;
                &lt;target&gt;12&lt;/target&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
</code></pre>
<pre><code class="language-java">//ioc的原型
//利用set动态控制值的注入   实现控制反转
private UserDao userDao;
public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
</code></pre>
<p>降低系统的耦合性</p>
<p><strong>控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法</strong>。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，所谓控制反转就是：获得依赖对象的方式反转了。</p>
<figure data-type="image" tabindex="2"><img src="https://img2018.cnblogs.com/blog/1917960/202001/1917960-20200113174808801-173696143.png" alt="img" loading="lazy"></figure>
<pre><code class="language-java">类型 变量名 = new 类型()
id = 变量名
class = new 的对象
property 相当于给对象中的属性设置一个值
</code></pre>
<p>所谓ioc，就是对象由spring来创建，管理，装配</p>
<h4 id="xml配置">xml配置</h4>
<pre><code class="language-java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;


&lt;/beans&gt;


ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);
</code></pre>
<p>带参构造</p>
<pre><code class="language-xm">//下表赋值
&lt;bean id=&quot;user&quot; class=&quot;com.feng.pojo.User&quot;&gt;
        &lt;constructor-arg index=&quot;0&quot; value=&quot;fengxie&quot;/&gt;
    &lt;/bean&gt;
//直接使用变量名
&lt;bean id=&quot;user&quot; class=&quot;com.feng.pojo.User&quot;&gt;
        &lt;constructor-arg name=&quot;name&quot; value=&quot;22222&quot;/&gt;
    &lt;/bean&gt;
</code></pre>
<p>导入其他配置文件</p>
<pre><code class="language-xm">&lt;import resource=&quot;beans.xml&quot;/&gt;
</code></pre>
<p>SET方式注入：</p>
<p>​	依赖注入：set方式注入</p>
<pre><code>1. 依赖：bean对象的创建依赖容器
1. 注入：bean对象的属性，由容器注入
</code></pre>
<p>bean的作用域</p>
<ol>
<li>单例模式</li>
<li>原型模式：每次从容器中get的是一个新对象</li>
<li>其余 request session application只能在web开发中使用</li>
</ol>
<h4 id="自动装配">自动装配</h4>
<pre><code class="language-xml">&lt;!--
    byname:自动在容器上下文寻找 set 方法对应id的值
	bytype :属性相同
    --&gt;
    &lt;bean id=&quot;people&quot; class=&quot;com.feng.pojo.People&quot; autowire=&quot;byName&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;feng&quot;/&gt;
    &lt;/bean&gt;


</code></pre>
<p>注解实现自动注入(需满足以下支持)（可以忽略set方法）</p>
<h4 id="context约束">context约束</h4>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:annotation-config/&gt;

&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">@Autowired(required = false)    //对象可以为NULL
@Qualifier(value=&quot;&quot;)

@Resource(name=&quot;&quot;)

//autowired resource都是自动装配
//autowired通过bytype 然后byname  resource先用byname 失败则使用bytype
</code></pre>
<h4 id="注解">注解：</h4>
<p>@Component</p>
<ol>
<li>dao【@Repository】</li>
<li>service【@Service】</li>
<li>controller【@Controller】</li>
</ol>
<h4 id="静态代理">静态代理：</h4>
<ol>
<li>
<p>接口</p>
<pre><code class="language-java">public interface Rent {
    public void rent();
}
</code></pre>
</li>
<li>
<p>真实角色</p>
<pre><code class="language-java">public class Host implements Rent{

    @Override
    public void rent() {
        System.out.println(&quot;房东出租房子&quot;);
    }
}
</code></pre>
</li>
<li>
<p>代理角色</p>
<pre><code class="language-java">public class Proxy implements  Rent{

    public Host host;

    public Proxy() {
    }

    public Proxy(Host host) {
        this.host = host;
    }



    @Override
    public void rent() {
        seeHouse();
        host.rent();
        hetong();
        fare();
    }

    public void seeHouse(){
        System.out.println(&quot;中介 带你看房&quot;);
    }

    public void hetong(){
        System.out.println(&quot;签合同&quot;);
    }

    public void fare(){
        System.out.println(&quot;收中介费&quot;);
    }
}
</code></pre>
</li>
<li>
<p>客户访问代理</p>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        Host host = new Host();

        Proxy proxy = new Proxy(host);

        proxy.rent();
    }
}
</code></pre>
</li>
</ol>
<h4 id="浅谈aop">浅谈AOP</h4>
<figure data-type="image" tabindex="3"><img src="http://localhost:4000/post-images/1648715767237.png" alt="" loading="lazy"></figure>
<h4 id="动态代理">动态代理</h4>
<pre><code class="language-java">import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
//使用这个类 自动生产代理类
public class ProxyInvocationHandler implements InvocationHandler {

    //被代理的接口
    private Object target;

    public void setTarget(Object target) {
        this.target = target;
    }

    //生成得到代理类
    public Object getProxy(){
        return Proxy.newProxyInstance(this.getClass().getClassLoader(),target.getClass().getInterfaces(),this);
    }

    //处理代理示例，返回结果
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //动态代理的本质就是使用反射去实现
        Object result = method.invoke(target, args);
        return result;
    }
}

</code></pre>
<h4 id="aop实现">AOP实现</h4>
<p>所需支持：</p>
<pre><code class="language-xml">    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.9.4&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<h4 id="aop组成">AOP组成</h4>
<figure data-type="image" tabindex="4"><img src="http://localhost:4000/post-images/1648715595163.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
</feed>